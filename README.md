# TopLeader Backend

Backend application for the TopLeader platform - a coaching and mentoring platform that connects coaches with users, manages scheduling, feedback, credits, and team collaboration.

## Why TopLeader?

TopLeader is a platform that helps organizations develop their people through professional coaching. It connects employees with certified coaches, manages coaching sessions, tracks progress, and provides insights through feedback and AI-powered analysis.

## Architecture Decisions

> **Key ADRs:** [Monolith Architecture](docs/adr/001-monolith-architecture.md) | [Session-based Auth](docs/adr/002-session-based-auth.md) | [Native Image Strategy](docs/adr/003-native-image-strategy.md)

### Why Java 25?

We use **Java 25** for several key benefits:

**Memory Optimization with Compact Object Headers (`-XX:+UseCompactObjectHeaders`):**
- Reduces object header size from 12 bytes to 8 bytes (32-bit mode) or from 16 bytes to 12 bytes (64-bit)
- **~10-15% memory reduction** for object-heavy applications
- Especially beneficial for applications with many small objects (entities, DTOs)
- Available as experimental feature in Java 24+, stable in Java 25

**Virtual Threads (Project Loom):**
- Lightweight threads for high-concurrency workloads
- No thread pool tuning required
- Perfect for I/O-bound operations (database, HTTP calls, email sending)

**Enhanced Pattern Matching:**
- Cleaner code with pattern matching for `switch` and `instanceof`
- Reduces boilerplate in data processing

**Better Native Image Support:**
- Java 25 + Spring Boot 4 have significantly improved GraalVM native image compatibility
- Reduced reflection requirements in the JDK itself
- Faster ahead-of-time (AOT) compilation

### Why Spring Boot 4?

We upgraded to **Spring Boot 4.0** for native image readiness:

**Improved Native Image Support:**
- Spring Framework 7 has first-class GraalVM native image support
- Most Spring components work out-of-the-box without reflection hints
- AOT (Ahead-of-Time) processing is more mature and reliable

**Reduced Reflection:**
- Spring Boot 4 minimizes runtime reflection
- Bean registration uses compile-time code generation
- Dependency injection is optimized for native compilation

**Jakarta EE 11:**
- Updated to latest Jakarta EE specifications
- Better alignment with modern Java ecosystem

**Virtual Threads Integration:**
- Native support for virtual threads in web layer
- Automatic thread management without configuration

### Why Monolith?

> See [ADR-001: Monolith Architecture](docs/adr/001-monolith-architecture.md) for full decision record.

We chose a monolithic architecture primarily for **cost savings**. A monolith is simpler to deploy, operate, and scale for our current needs. It avoids the operational complexity and infrastructure costs of microservices (multiple deployments, service mesh, distributed tracing complexity, etc.). For a coaching platform with predictable load patterns, a well-structured monolith provides the best balance of simplicity and performance.

### Why Jetty?

We use **Jetty** instead of Tomcat because it's **lightweight** and doesn't carry the overhead of Tomcat. Jetty has a smaller memory footprint and faster startup time, which aligns with our goal of keeping the application lean and efficient.

### Why Avoid Reflection-based Libraries?

We deliberately avoid libraries that rely heavily on reflection. For example, we use **Failsafe** for resilience patterns because it works without reflection. This approach:
- Improves startup time
- Reduces memory usage
- Makes the codebase more predictable and easier to debug
- Prepares the application for GraalVM native image compilation

### Why Log4j2 over Logback?

We use **Log4j2** instead of Spring Boot's default Logback for several reasons:
- **Better performance** with async logging and garbage-free logging at steady state
- **More flexible configuration** with support for multiple output formats
- **Better suited for native images** - Log4j2 has better GraalVM native image support

### Why Pre-generated OpenAPI?

We disable dynamic OpenAPI generation at runtime (`springdoc.api-docs.enabled: false`) and pre-generate `openapi.yaml` during CI/CD:
- **No runtime reflection** - dynamic spec generation uses reflection which impacts native image compatibility
- **Faster startup** - no need to scan controllers and build spec at runtime

The spec is generated by `OpenApiGeneratorTest` which runs during deployment and outputs to `src/main/resources/static/openapi.yaml`.

### Why Spring Session JDBC over JWT?

> See [ADR-002: Session-based Auth](docs/adr/002-session-based-auth.md) for full decision record.

We use **Spring Session JDBC** (server-side sessions) instead of JWT tokens for **simplicity**:
- **No token management complexity** - no refresh tokens, no token rotation, no blacklisting
- **Instant invalidation** - logout works immediately, no waiting for token expiry
- **Smaller payloads** - session ID is smaller than JWT with claims
- **Server-side control** - easy to inspect, modify, or revoke sessions
- **Already have a database** - no additional infrastructure needed (Redis, etc.)

For a monolithic application with a single database, server-side sessions are simpler and more secure than JWT.

### Why Gradle over Maven?

We migrated from Maven to **Gradle** (Kotlin DSL) for several reasons:
- **Faster builds** - incremental builds, build cache, and parallel execution
- **Better dependency management** - cleaner syntax, easier version catalogs
- **Kotlin DSL** - type-safe configuration with IDE autocompletion
- **Flexible** - easier to customize build logic without plugins
- **Modern** - aligns with our goal of using modern, efficient tooling

### Why Terraform?

We use **Terraform** for infrastructure as code (IaC):
- **Declarative** - define desired state, Terraform handles the rest
- **Multi-cloud** - works with GCP, AWS, Azure, and other providers
- **Version control** - infrastructure changes are tracked in Git
- **Plan & Apply** - preview changes before applying them
- **State management** - tracks resource state for safe updates and rollbacks

### Future Tech Plans

> See [ADR-003: Native Image Strategy](docs/adr/003-native-image-strategy.md) for full decision record.

**GraalVM Native Images:**
- Remove **iCal4j** library (replace with simpler implementation)
- Remove **Hibernate** (migrate to lighter alternatives like JDBC or jOOQ)

Native images provide instant startup and reduced memory footprint, which is ideal for cloud deployment and cost optimization.

**Migration to Cloud Run:**
- Move from GKE to **Google Cloud Run** for simplified container orchestration
- Pay-per-request pricing model for cost optimization
- Automatic scaling to zero when idle
- Native image + Cloud Run = instant cold starts and minimal costs

## Tech Stack

- **Java 25** with Spring Boot 4.0.1
- **PostgreSQL 15** database
- **Spring Data JPA** with Hibernate 7.x
- **Spring Security** (session-based authentication)
- **Spring AI** with OpenAI integration
- **Spring Session JDBC** for distributed sessions
- **Flyway** for database migrations
- **Lombok** 1.18.42 for boilerplate reduction
- **Gradle 9.x** (Kotlin DSL) for build management
- **Docker Compose** for local development
- **Virtual Threads** enabled (Java 21+ feature)
- **OpenTelemetry** for observability

## Prerequisites

- **Java 25** (managed via SDKMAN recommended)
- **Gradle 9.x** (managed via SDKMAN recommended)
- **Docker & Docker Compose** (for PostgreSQL)
- **Git**

## Getting Started

### 1. Clone the Repository

```bash
git clone <repository-url>
cd top-leader-be
```

### 2. Start PostgreSQL Database

The project uses Docker Compose to run PostgreSQL locally:

```bash
docker-compose up -d
```

This starts PostgreSQL 15 on port `5434` with:
- Database: `top_leader`
- Username: `root`
- Password: `postgres`

### 3. Configure Environment

The application uses `src/main/resources/application.yml` for configuration. For local development, the defaults work out of the box.

Required external service configurations (add to environment or application.yml):
- **OpenAI API Key** (for AI features)
- **Google OAuth** credentials (for calendar integration)
- **Calendly** credentials (for scheduling integration)
- **GCP Storage** credentials (for file storage)

### 4. Build the Application

```bash
./gradlew compileJava
```

### 5. Run Database Migrations

Flyway migrations run automatically on application startup.

### 6. Run the Application

```bash
./gradlew bootRun
```

The application will start on `http://localhost:8080`

## API Documentation

Interactive API documentation is available via Swagger UI when the application is running:

**Swagger UI:** `http://localhost:8080/swagger-ui.html`

## Project Structure

```
src/main/java/com/topleader/topleader/
├── admin/                  # Admin views and management
├── coach/                  # Coach profiles and availability
├── common/                 # Shared utilities and cross-cutting concerns
│   ├── ai/                 # AI integrations (OpenAI)
│   ├── calendar/           # Calendar integrations (Google, Calendly)
│   ├── email/              # Email sending (SMTP)
│   ├── exception/          # Custom exceptions and error handling
│   ├── notification/       # Notification system
│   ├── password/           # Password management
│   └── util/               # Utilities and converters
├── configuration/          # Security, async, and app configs
├── credit/                 # Credit system management
├── feedback/               # Feedback forms and responses
├── history/                # History tracking
├── hr/                     # HR user management
├── message/                # User messaging system
├── myteam/                 # Team management
├── session/                # Session management
└── user/                   # Core user entity and features

src/main/resources/
├── db/migration/1.0.0/     # Flyway database migrations (consolidated)
├── application.yml         # Main configuration file
└── templates/              # Email templates
```

## Key Features

### Authentication & Authorization
- Session-based authentication with Spring Security
- Role-based access control (RBAC)
- Roles: `RESPONDENT`, `USER`, `MANAGER`, `COACH`, `HR`, `ADMIN`

### User Management
- User profiles and preferences
- Team management
- HR admin capabilities
- Coach-coachee relationships

### Session Management
- Scheduled coaching sessions
- Calendar integrations (Google Calendar, Calendly)
- iCal format support
- Session history and tracking

### Credit System
- Credit allocation and management
- Company package management
- User allocation tracking

### Feedback System
- Feedback forms and responses
- Feedback notifications
- Summary generation

### AI Integration
- OpenAI integration via Spring AI
- AI-powered features
- Image generation support

### External Integrations
- Google OAuth and Calendar API
- Calendly scheduling API
- GCP Cloud Storage
- SMTP email sending

## Testing

### Run All Tests

```bash
./gradlew test
```

### Run Specific Test Class

```bash
./gradlew test --tests "ClassName"
```

### Run Integration Tests

```bash
./gradlew check
```

The test suite uses:
- **Spring Boot Test** with `@SpringBootTest`
- **Testcontainers** for PostgreSQL
- **GreenMail** for email testing
- **WireMock** for external API mocking
- **JSON Unit** for JSON assertions

Test data is loaded from `src/test/resources/sql/` scripts.

## Build & Deployment

### Build Without Tests

```bash
./gradlew build -x test
```

The build produces `build/libs/top-leader.jar`

### Docker Image

The project includes Spring Boot buildpack support for creating OCI images.

## Database Migrations

Flyway migrations are located in `src/main/resources/db/migration/1.0.0/`

We consolidated **80+ individual migrations** into a single `V1.0.0.1__init.sql` script. This prevents long Flyway scan times and  speeds up application startup.

Migrations run automatically on application startup.

## Configuration

Key configuration properties in `application.yml`:

- **Database**: PostgreSQL on `localhost:5434`
- **Server Port**: `8080`
- **Virtual Threads**: Enabled
- **Docker Compose**: Auto-enabled for local development
- **Flyway**: Auto-migration enabled
- **JPA**: Validate mode with lazy initialization
- **Session**: JDBC-backed sessions
- **Actuator**: Health, metrics, and Prometheus endpoints exposed

## Monitoring & Observability

- **Spring Boot Actuator** endpoints: `/actuator/health`,
- **OpenTelemetry** integration for traces and metrics
- **Grafana Cloud** support (configured via environment)

## Code Style & Patterns

- Use `var` for local variables
- Records for DTOs
- Lombok annotations (`@Data`, `@Accessors(chain = true)`)
- Jakarta validation (`@NotNull`, `@Valid`)
- Entity pattern with `@Entity` and audit fields
- Repository pattern with `JpaRepository`
- Controller pattern with `@RestController` and `/api/latest/*` paths
- Secured endpoints with `@Secured` annotations
- Prefer streams over loops
- No JavaDoc above methods

