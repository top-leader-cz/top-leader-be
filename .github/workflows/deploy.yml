# This workflow will build a Java project with Gradle, and cache/restore any dependencies to improve the workflow execution time
name: Build/Deploy top-leader-be

on:
  push:
    tags:
      - 'qa-deploy'
      - 'qa-deploy-*'
      - 'release-v*.*.*'
  pull_request:
    branches: [ "develop", "main" ]

jobs:
  build:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Set up JDK 25
      uses: actions/setup-java@v4
      with:
        java-version: '25'
        distribution: 'corretto'
        cache: gradle

    - name: Setup Gradle
      uses: gradle/actions/setup-gradle@v4
      with:
        cache-read-only: ${{ github.ref != 'refs/heads/main' }}

    - name: Build and verify coverage (min 80%)
      run: gradle build jacocoTestReport jacocoTestCoverageVerification --parallel --build-cache


  deploy-qa:
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/qa-deploy')
    runs-on: ubuntu-latest
    env:
      REGION: europe-west3
      SERVICE_NAME: top-leader-qa
      PROJECT_ID: topleader-394306
      IMAGE_NAME: top-leader-be
    steps:
      - uses: actions/checkout@v4

      - name: Cloud Authentication
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_CREDENTIALS }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker for Artifact Registry
        run: gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev,gcr.io

      - name: Build and push Docker image
        run: |
          IMAGE_URL=${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/top-leader/${{ env.IMAGE_NAME }}
          SHORT_SHA=$(git rev-parse --short HEAD)
          docker build -t ${IMAGE_URL}:latest -t ${IMAGE_URL}:qa-${SHORT_SHA} .
          docker push ${IMAGE_URL}:latest
          docker push ${IMAGE_URL}:qa-${SHORT_SHA}

          # Get the pushed image digest to force new Cloud Run revision
          DIGEST=$(gcloud artifacts docker images describe ${IMAGE_URL}:latest --format='get(image_summary.digest)' --project=${{ env.PROJECT_ID }})
          echo "IMAGE_WITH_DIGEST=${IMAGE_URL}@${DIGEST}" >> $GITHUB_ENV

          # Get the pushed image digest to force new Cloud Run revision
          DIGEST=$(gcloud artifacts docker images describe ${IMAGE_URL}:latest --format='get(image_summary.digest)' --project=${{ env.PROJECT_ID }})
          echo "IMAGE_WITH_DIGEST=${IMAGE_URL}@${DIGEST}" >> $GITHUB_ENV

      - name: Deploy to Cloud Run QA
        run: |
          # Replace :latest with exact digest to force new revision
          sed -i "s|image:.*|image: ${{ env.IMAGE_WITH_DIGEST }}|" src/main/cloudrun/service-qa.yaml

          gcloud run services replace src/main/cloudrun/service-qa.yaml \
            --region=${{ env.REGION }} \
            --project=${{ env.PROJECT_ID }}

          # Allow unauthenticated access
          gcloud run services add-iam-policy-binding ${{ env.SERVICE_NAME }} \
            --region=${{ env.REGION }} \
            --member="allUsers" \
            --role="roles/run.invoker" \
            --project=${{ env.PROJECT_ID }}

      - name: Cleanup old revisions (keep last 2)
        run: |
          echo "Fetching QA revisions..."
          REVISIONS=$(gcloud run revisions list \
            --service=${{ env.SERVICE_NAME }} \
            --region=${{ env.REGION }} \
            --platform=managed \
            --sort-by=~metadata.creationTimestamp \
            --format="value(metadata.name)" \
            --project=${{ env.PROJECT_ID }} | tail -n +3)

          if [ -z "$REVISIONS" ]; then
            echo "No old revisions to delete"
          else
            echo "Deleting old revisions: $REVISIONS"
            for REVISION in $REVISIONS; do
              gcloud run revisions delete $REVISION \
                --region=${{ env.REGION }} \
                --platform=managed \
                --project=${{ env.PROJECT_ID }} \
                --quiet || echo "Failed to delete $REVISION"
            done
          fi

      - name: Cleanup old images (keep latest + 1 previous QA)
        run: |
          IMAGE_PATH=${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/top-leader/${{ env.IMAGE_NAME }}
          echo "Cleaning up old images..."

          # 1. Delete old QA tagged images first (keep 2 newest by creation time)
          OLD_QA=$(gcloud artifacts docker images list ${IMAGE_PATH} \
            --include-tags \
            --sort-by=~CREATE_TIME \
            --format="csv[no-heading](DIGEST,TAGS)" \
            --project=${{ env.PROJECT_ID }} 2>/dev/null | \
            grep 'qa-' | tail -n +3 | cut -d',' -f1)

          for DIGEST in $OLD_QA; do
            echo "Deleting old QA image: ${DIGEST}"
            gcloud artifacts docker images delete ${IMAGE_PATH}@${DIGEST} \
              --project=${{ env.PROJECT_ID }} \
              --quiet --delete-tags || echo "Failed to delete ${DIGEST}"
          done

          # 2. Delete all untagged images (orphaned platform manifests)
          UNTAGGED=$(gcloud artifacts docker images list ${IMAGE_PATH} \
            --include-tags \
            --format="get(DIGEST)" \
            --filter="tags=''" \
            --project=${{ env.PROJECT_ID }} 2>/dev/null)

          for DIGEST in $UNTAGGED; do
            echo "Deleting untagged: ${DIGEST}"
            gcloud artifacts docker images delete ${IMAGE_PATH}@${DIGEST} \
              --project=${{ env.PROJECT_ID }} \
              --quiet --delete-tags || echo "Failed to delete ${DIGEST}"
          done

  deploy-prod:
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/release-v')
    runs-on: ubuntu-latest
    permissions:
      contents: write
    env:
      REGION: europe-west3
      SERVICE_NAME: top-leader-prod
      PROJECT_ID: topleader-394306
      IMAGE_NAME: top-leader-be
    steps:
      - uses: actions/checkout@v4

      - name: Cloud Authentication
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_CREDENTIALS }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker for Artifact Registry
        run: gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev,gcr.io

      - name: Build and push Docker image
        run: |
          VERSION="${GITHUB_REF#refs/tags/release-v}"
          IMAGE_URL=${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/top-leader/${{ env.IMAGE_NAME }}
          docker build -t ${IMAGE_URL}:${VERSION} .
          docker push ${IMAGE_URL}:${VERSION}

          # Get the pushed image digest for deploy verification
          DIGEST=$(gcloud artifacts docker images describe ${IMAGE_URL}:${VERSION} --format='get(image_summary.digest)' --project=${{ env.PROJECT_ID }})
          echo "IMAGE_WITH_DIGEST=${IMAGE_URL}@${DIGEST}" >> $GITHUB_ENV

      - name: Deploy to Cloud Run PROD
        run: |
          # Replace image with exact digest to guarantee correct version
          sed -i "s|image:.*|image: ${{ env.IMAGE_WITH_DIGEST }}|" src/main/cloudrun/service-prod.yaml

          # Deploy using service YAML
          gcloud run services replace src/main/cloudrun/service-prod.yaml \
            --region=${{ env.REGION }} \
            --project=${{ env.PROJECT_ID }}

          # Allow unauthenticated access
          gcloud run services add-iam-policy-binding ${{ env.SERVICE_NAME }} \
            --region=${{ env.REGION }} \
            --member="allUsers" \
            --role="roles/run.invoker" \
            --project=${{ env.PROJECT_ID }}

      - name: Verify deployment
        run: |
          RUNNING_IMAGE=$(gcloud run services describe ${{ env.SERVICE_NAME }} \
            --region=${{ env.REGION }} \
            --project=${{ env.PROJECT_ID }} \
            --format='get(spec.template.spec.containers[0].image)')
          echo "Running image: ${RUNNING_IMAGE}"
          echo "Expected image: ${{ env.IMAGE_WITH_DIGEST }}"
          if [ "${RUNNING_IMAGE}" != "${{ env.IMAGE_WITH_DIGEST }}" ]; then
            echo "ERROR: Deployed image does not match expected image!"
            exit 1
          fi
          echo "Deployment verified successfully"

      - name: Cleanup old revisions (keep last 3)
        run: |
          echo "Fetching PROD revisions..."
          REVISIONS=$(gcloud run revisions list \
            --service=${{ env.SERVICE_NAME }} \
            --region=${{ env.REGION }} \
            --platform=managed \
            --sort-by=~metadata.creationTimestamp \
            --format="value(metadata.name)" \
            --project=${{ env.PROJECT_ID }} | tail -n +4)

          if [ -z "$REVISIONS" ]; then
            echo "No old revisions to delete"
          else
            echo "Deleting old revisions: $REVISIONS"
            for REVISION in $REVISIONS; do
              gcloud run revisions delete $REVISION \
                --region=${{ env.REGION }} \
                --platform=managed \
                --project=${{ env.PROJECT_ID }} \
                --quiet || echo "Failed to delete $REVISION"
            done
          fi

      - name: Cleanup old images (keep last 3 versions)
        run: |
          IMAGE_PATH=${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/top-leader/${{ env.IMAGE_NAME }}
          echo "Cleaning up old images..."

          # 1. Delete old PROD versioned images (keep 3 newest by creation time)
          OLD_VERSIONS=$(gcloud artifacts docker images list ${IMAGE_PATH} \
            --include-tags \
            --sort-by=~CREATE_TIME \
            --format="csv[no-heading](DIGEST,TAGS)" \
            --project=${{ env.PROJECT_ID }} 2>/dev/null | \
            grep -E '[0-9]+\.[0-9]+\.[0-9]+' | tail -n +4 | cut -d',' -f1)

          for DIGEST in $OLD_VERSIONS; do
            echo "Deleting old version: ${DIGEST}"
            gcloud artifacts docker images delete ${IMAGE_PATH}@${DIGEST} \
              --project=${{ env.PROJECT_ID }} \
              --quiet --delete-tags || echo "Failed to delete ${DIGEST}"
          done

          # 2. Delete all untagged images (orphaned platform manifests)
          UNTAGGED=$(gcloud artifacts docker images list ${IMAGE_PATH} \
            --include-tags \
            --format="get(DIGEST)" \
            --filter="tags=''" \
            --project=${{ env.PROJECT_ID }} 2>/dev/null)

          for DIGEST in $UNTAGGED; do
            echo "Deleting untagged: ${DIGEST}"
            gcloud artifacts docker images delete ${IMAGE_PATH}@${DIGEST} \
              --project=${{ env.PROJECT_ID }} \
              --quiet --delete-tags || echo "Failed to delete ${DIGEST}"
          done

      - name: Create GitHub Release with changelog
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          TAG_NAME="${GITHUB_REF#refs/tags/}"
          gh release create "$TAG_NAME" \
            --title "$TAG_NAME" \
            --generate-notes
