# This workflow will build a Java project with Gradle, and cache/restore any dependencies to improve the workflow execution time
name: Build/Deploy top-leader-be

on:
  push:
    tags:
      - 'qa-deploy'
      - 'qa-deploy-*'
      - 'release-v*.*.*'
  pull_request:
    branches: [ "develop", "main" ]

jobs:
  build:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Set up JDK 25
      uses: actions/setup-java@v4
      with:
        java-version: '25'
        distribution: 'corretto'
        cache: gradle

    - name: Setup Gradle
      uses: gradle/actions/setup-gradle@v4
      with:
        cache-read-only: ${{ github.ref != 'refs/heads/main' }}

    - name: Build and verify coverage (min 80%)
      run: gradle build jacocoTestReport jacocoTestCoverageVerification --parallel --build-cache


  deploy-qa:
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/qa-deploy')
    runs-on: ubuntu-latest
    env:
      REGION: europe-west3
      SERVICE_NAME: top-leader-qa
      PROJECT_ID: topleader-394306
      IMAGE_NAME: top-leader-be
    steps:
      - uses: actions/checkout@v4

      - name: Cloud Authentication
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_CREDENTIALS }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker for Artifact Registry
        run: gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev

      - name: Build and push Docker image
        run: |
          SHORT_SHA=$(git rev-parse --short "$GITHUB_SHA")
          IMAGE_URL=${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/top-leader/${{ env.IMAGE_NAME }}
          docker build -t ${IMAGE_URL}:${SHORT_SHA} -t ${IMAGE_URL}:latest .
          docker push ${IMAGE_URL}:${SHORT_SHA}
          docker push ${IMAGE_URL}:latest

      - name: Deploy to Cloud Run QA
        run: |
          SHORT_SHA=$(git rev-parse --short "$GITHUB_SHA")
          IMAGE_URL=${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/top-leader/${{ env.IMAGE_NAME }}:${SHORT_SHA}

          # Update image tag in service YAML
          sed -i "s|image:.*|image: ${IMAGE_URL}|" src/main/cloudrun/service-qa.yaml

          # Deploy using service YAML
          gcloud run services replace src/main/cloudrun/service-qa.yaml \
            --region=${{ env.REGION }} \
            --project=${{ env.PROJECT_ID }}

          # Allow unauthenticated access
          gcloud run services add-iam-policy-binding ${{ env.SERVICE_NAME }} \
            --region=${{ env.REGION }} \
            --member="allUsers" \
            --role="roles/run.invoker" \
            --project=${{ env.PROJECT_ID }}

      - name: Cleanup old revisions (keep last 2)
        run: |
          echo "Fetching QA revisions..."
          REVISIONS=$(gcloud run revisions list \
            --service=${{ env.SERVICE_NAME }} \
            --region=${{ env.REGION }} \
            --platform=managed \
            --sort-by=~metadata.creationTimestamp \
            --format="value(metadata.name)" \
            --project=${{ env.PROJECT_ID }} | tail -n +3)

          if [ -z "$REVISIONS" ]; then
            echo "No old revisions to delete"
          else
            echo "Deleting old revisions: $REVISIONS"
            for REVISION in $REVISIONS; do
              gcloud run revisions delete $REVISION \
                --region=${{ env.REGION }} \
                --platform=managed \
                --project=${{ env.PROJECT_ID }} \
                --quiet || echo "Failed to delete $REVISION"
            done
          fi

      - name: Cleanup old images (keep last 2)
        run: |
          IMAGE_PATH=${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/top-leader/${{ env.IMAGE_NAME }}
          echo "Fetching QA image digests..."
          DIGESTS=$(gcloud artifacts docker images list ${IMAGE_PATH} \
            --sort-by=~CREATE_TIME \
            --format="get(version)" \
            --project=${{ env.PROJECT_ID }} | tail -n +3)

          if [ -z "$DIGESTS" ]; then
            echo "No old images to delete"
          else
            echo "Deleting old images..."
            for DIGEST in $DIGESTS; do
              gcloud artifacts docker images delete ${IMAGE_PATH}@${DIGEST} \
                --project=${{ env.PROJECT_ID }} \
                --quiet --delete-tags || echo "Failed to delete ${DIGEST}"
            done
          fi

  deploy-prod:
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/release-v')
    runs-on: ubuntu-latest
    permissions:
      contents: write
    env:
      REGION: europe-west3
      SERVICE_NAME: top-leader-prod
      PROJECT_ID: topleader-394306
      IMAGE_NAME: top-leader-be
    steps:
      - uses: actions/checkout@v4

      - name: Cloud Authentication
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_CREDENTIALS }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker for Artifact Registry
        run: gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev

      - name: Build and push Docker image
        run: |
          VERSION="${GITHUB_REF#refs/tags/release-v}"
          IMAGE_URL=${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/top-leader/${{ env.IMAGE_NAME }}
          docker build -t ${IMAGE_URL}:${VERSION} -t ${IMAGE_URL}:latest .
          docker push ${IMAGE_URL}:${VERSION}
          docker push ${IMAGE_URL}:latest

      - name: Deploy to Cloud Run PROD
        run: |
          VERSION="${GITHUB_REF#refs/tags/release-v}"
          IMAGE_URL=${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/top-leader/${{ env.IMAGE_NAME }}:${VERSION}

          # Update image tag in service YAML
          sed -i "s|image:.*|image: ${IMAGE_URL}|" src/main/cloudrun/service-prod.yaml

          # Deploy using service YAML
          gcloud run services replace src/main/cloudrun/service-prod.yaml \
            --region=${{ env.REGION }} \
            --project=${{ env.PROJECT_ID }}

          # Allow unauthenticated access
          gcloud run services add-iam-policy-binding ${{ env.SERVICE_NAME }} \
            --region=${{ env.REGION }} \
            --member="allUsers" \
            --role="roles/run.invoker" \
            --project=${{ env.PROJECT_ID }}

      - name: Cleanup old revisions (keep last 3)
        run: |
          echo "Fetching PROD revisions..."
          REVISIONS=$(gcloud run revisions list \
            --service=${{ env.SERVICE_NAME }} \
            --region=${{ env.REGION }} \
            --platform=managed \
            --sort-by=~metadata.creationTimestamp \
            --format="value(metadata.name)" \
            --project=${{ env.PROJECT_ID }} | tail -n +4)

          if [ -z "$REVISIONS" ]; then
            echo "No old revisions to delete"
          else
            echo "Deleting old revisions: $REVISIONS"
            for REVISION in $REVISIONS; do
              gcloud run revisions delete $REVISION \
                --region=${{ env.REGION }} \
                --platform=managed \
                --project=${{ env.PROJECT_ID }} \
                --quiet || echo "Failed to delete $REVISION"
            done
          fi

      - name: Cleanup old images (keep last 3)
        run: |
          IMAGE_PATH=${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/top-leader/${{ env.IMAGE_NAME }}
          echo "Fetching PROD image digests..."
          DIGESTS=$(gcloud artifacts docker images list ${IMAGE_PATH} \
            --sort-by=~CREATE_TIME \
            --format="get(version)" \
            --project=${{ env.PROJECT_ID }} | tail -n +4)

          if [ -z "$DIGESTS" ]; then
            echo "No old images to delete"
          else
            echo "Deleting old images..."
            for DIGEST in $DIGESTS; do
              gcloud artifacts docker images delete ${IMAGE_PATH}@${DIGEST} \
                --project=${{ env.PROJECT_ID }} \
                --quiet --delete-tags || echo "Failed to delete ${DIGEST}"
            done
          fi

      - name: Create GitHub Release with changelog
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          TAG_NAME="${GITHUB_REF#refs/tags/}"
          gh release create "$TAG_NAME" \
            --title "$TAG_NAME" \
            --generate-notes
